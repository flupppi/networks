"""Solutions for the Exercises"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_network_analysis.ipynb.

# %% auto 0
__all__ = ['n', 'n_slider', 'k_slider', 'generate_random_tree', 'draw_trees', 'giant_component_size', 'update_graph']

# %% ../nbs/04_network_analysis.ipynb 3
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

# %% ../nbs/04_network_analysis.ipynb 17
n = 10

# %% ../nbs/04_network_analysis.ipynb 18
# Generate a random tree using the Prüfer sequence approach
def generate_random_tree(num_nodes, seed=None):
    if seed is not None:
        np.random.seed(seed)
    # Generate a Prüfer sequence of length (num_nodes - 2)
    prufer_sequence = np.random.randint(0, num_nodes, size=(num_nodes - 2))
    # Initialize degree of each node to 1
    degree = [1] * num_nodes
    for node in prufer_sequence:
        degree[node] += 1
    # Initialize the tree's edges
    edges = []
    for node in prufer_sequence:
        for i in range(len(degree)):
            if degree[i] == 1:  # Find the first leaf node
                edges.append((i, node))
                degree[i] -= 1
                degree[node] -= 1
                break
    # Add the final edge
    u, v = [i for i in range(len(degree)) if degree[i] == 1]
    edges.append((u, v))
    return nx.Graph(edges)

# %% ../nbs/04_network_analysis.ipynb 20
# Function to draw trees side-by-side
def draw_trees(trees, titles):
    fig, axes = plt.subplots(1, len(trees), figsize=(15, 5))
    for ax, tree, title in zip(axes, trees, titles):
        pos = nx.spring_layout(tree, seed=42)  # Use spring layout for consistency
        nx.draw(tree, pos, with_labels=True, ax=ax, node_color="lightblue", edge_color="gray", node_size=500)
        ax.set_title(title)
    plt.show()

# %% ../nbs/04_network_analysis.ipynb 25
def giant_component_size(k):
    # Solve S = 1 - exp(-k * S)
    func = lambda S: S - (1 - np.exp(-k * S))
    S_guess = 0.0001 if k < 1 else 0.5
    S_solution, = fsolve(func, S_guess)
    return S_solution

# %% ../nbs/04_network_analysis.ipynb 27
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
from scipy.optimize import fsolve
import ipywidgets as widgets
from IPython.display import display

# %% ../nbs/04_network_analysis.ipynb 28
# Function to solve S = 1 - exp(-k * S)
def giant_component_size(k):
    if k <= 0:
        return 0.0
    func = lambda S: S - (1 - np.exp(-k * S))
    S_guess = 0.0001 if k < 1 else 0.5
    S_solution, = fsolve(func, S_guess)
    return S_solution

# %% ../nbs/04_network_analysis.ipynb 29
# Function to update the graph
def update_graph(n=100, k_bar=0.5):
    m = int(k_bar * n / 2)
    G = nx.gnm_random_graph(n, m)

    # Theoretical giant component size
    S_theory = giant_component_size(k_bar)
    theoretical_size = int(S_theory * n)

    # Actual largest component
    if nx.is_connected(G):
        largest_cc_nodes = list(G.nodes())
    else:
        largest_cc_nodes = max(nx.connected_components(G), key=len)

    largest_cc = G.subgraph(largest_cc_nodes)

    # Plotting
    plt.figure(figsize=(6, 6))
    pos = nx.spring_layout(G, seed=42)
    node_colors = ['red' if node in largest_cc_nodes else 'lightgray' for node in G.nodes()]
    nx.draw(G, pos, node_color=node_colors, node_size=40, with_labels=False, edge_color='gray')
    plt.title(f'n = {n}, k_bar = {k_bar:.2f}\nGiant component size = {len(largest_cc)} (theory: ~{theoretical_size})')
    plt.axis('off')
    plt.show()


# %% ../nbs/04_network_analysis.ipynb 30
# Widgets
n_slider = widgets.IntSlider(value=100, min=20, max=500, step=10, description='Nodes (n):')
k_slider = widgets.FloatSlider(value=0.5, min=0.0, max=3.0, step=0.05, description='Avg. Degree (k̄):')

# Interactive output
widgets.interact(update_graph, n=n_slider, k_bar=k_slider)
